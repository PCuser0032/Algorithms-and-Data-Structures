
# Поиск минимального значения

---

## Условие задачи

Дан список элементов некоторой длины N. Необходимо найти минимальное значение элемента в списке.

---

## Начальные рассуждения

Начнём с того, что вообще нужно сделать, чтобы _найти минимальное значение_ в списке? Для этого список нужно _просмотреть_, сравнивая при этом минимальное значение со значением текущего выбранного элемента из списка, и, если его значение меньше, чем минимальное значение, то оно принимается в качестве нового минимального значения.

---

## Алгоритм решения

Ниже приведён алгоритм решения на языке программирования `Kotlin`:

```kotlin
fun main(args: Array<String>) {

    val arr: IntArray = intArrayOf(1, 10, 0, 0, 5, 109, 1, 2000, 70, 2, 909, 674, 1, 0)

    var min: Int = arr[0]
    
    // Перебор элементов в цикле `for`:
    for (i in 1..<arr.size) {

        // Проверка выполнения условия на то,
        // что значение текущего элемента меньше,
        // чем текущее минимальное значение:
        if (arr[i] < min) {

            // Присваивание значения переменной `min`
            min = arr[i]
        }
    }

    // Вывод исходного массива на экран:
    println("Array: { ${arr.joinToString()} }")

    print("Min value in array is $min")
}
```

**Пояснение к алгоритму**

Элемент массива `arr[0]` выбран в качестве начального значения переменной `min` не случайно: если в качестве начального значения принять `0`, то в случае, когда в массиве не содержится `0`, все значения будут пропущены, и алгоритм выдаст неправильное значение. 

---

## Определение сложности алгоритма

Для определения сложности алгоритма используется нотация **O** ("О-большое").

В ней определяется количество действий (элементарных операций), которые необходимо выполнить алгоритму для его завершения.

Используется запись следующего вида: `O(<количество операций>)`.

Ниже приведено несколько записей в нотации "О-большое" (в порядке возрастания сложности):

| Запись       | Наименование              | Пример алгоритма                                                                                                               |
|:-------------|:--------------------------|:-------------------------------------------------------------------------------------------------------------------------------|
| `O(1)`       | _константная_             | Определение чётности целого числа (представленного в двоичном виде)                                                            |
| `O(log(N))`  | _логарифмическая_         | Бинарный (двоичный поиск)                                                                                                      |
| `O(N)`       | _линейная_                | Поиск наименьшего или наибольшего элемента в неотсортированном массиве                                                         |
| `O(Nlog(N))` | _линейно-логарифмическая_ | Некоторые алгоритмы сортировки (сортировка слиянием, пирамидальная сортировка, интроспективная сортировка, сортировка Timsort) |
| `O(N^2)`     | _квадратическая_          | Сортировка пузырьком, сортировка вставками, прямая свёртка                                                                     |
| `O(N^3)`     | _кубическая_              | Обычное умножение двух _n_ &#215; _n_ матриц                                                                                   |
| `O(N!)`      | _факториальная_           | Решение задачи коммивояжёра полным перебором                                                                                   |

---

### Временная сложность

Временная сложность алгоритма будет составлять `O(N)`: необходимо просмотреть весь список элементов, сравнивая минимальное значение с текущим значением элемента.

### Пространственная сложность

Пространственная сложность (память) составит `O(1)`: дополнительное выделение памяти не требуется, так рассматривается набор элементов фиксированного (некоторого) размера (N).

---

## Проверка корректности работы алгоритма

**Покрытие тестами**

Для проверки корректности работы алгоритма должен быть разработан набор тестов, позволяющих выявить те ситуации, при которых алгоритм даёт неправильное решение.

**Набор тестов**

Не содержится ни одного элемента:  
`[]`

Один элемент:  
`[ 1 ]`

Элемент с минимальным значением находится в начале:  
`[ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 ]`

Элемент с минимальным значением находится в конце:  
`[ 1, 2, 3, 4, 5, 6, 7, 8, 9, 0 ]`

Все элементы имеют одинаковое значение:  
`[ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 ]`

Все элементы имеют отрицательные значения:  
`[ -1, -2, -3, -4, -5, -6, -7, -8, -9, -10 ]`

Все элементы имеют одинаковое отрицательное значение:  
`[ -1, -1, -1, -1, -1, -1, -1, -1, -1, -1 ]`

Содержатся отрицательные и положительные значения:  
`[ -5, -4, -3, -2, -1, 0, 1, 2, 3, 4 ]`

---

## Дополнение к программному коду

Запись `args: Array<String>` определяет массив аргументов, которые могут быть переданы в функцию `main()`.
В таком случае требуется преобразование строковых значений массива к целочисленным:

```kotlin
val arr: IntArray = args.map { element -> element.toInt() }.toIntArray()
```

Метод `map()` формирует новую коллекцию, последовательно применяя функцию преобразования (лямбда-выражение `element -> element.toInt()`) к элементам исходной коллекции (в данном случае `args`).

Метод `toIntArray()` выполняет преобразование коллекции к целочисленному массиву.